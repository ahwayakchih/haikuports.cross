name: bootstrap
on:
  push:
    branches: [ workflow ]
  pull_request:
    branches: [ workflow ]
jobs:
  bootstrap-riscv64:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: install missing tools
      # attr is for `setfattr` used for extended attributes
      # nasm is an assembler
      run: sudo apt install -y nasm attr
    - name: prepare workspace
      id: workspace
      run: |
        WORK_PATH=$(dirname ${GITHUB_WORKSPACE})
        mkdir -p "$WORK_PATH/bin"
        echo "WORK_PATH=$WORK_PATH" >> "$GITHUB_ENV"
        echo "$WORK_PATH/bin" >> "$GITHUB_PATH"
    - name: git haiku
      run: git -C "${{env.WORK_PATH}}" clone --depth 1 https://review.haiku-os.org/haiku
    # Since we're doing only a shallow clone, and builds may need a hrev tag, we need to get that tag now
    - name: haiku hrev
      run: |
        HREV=$(git -c 'versionsort.suffix=-' ls-remote --tags --sort='v:refname' https://review.haiku-os.org/haiku | grep $(git -C "${{env.WORK_PATH}}/haiku" rev-parse HEAD) | cut --fields=2 | cut --delimiter=/ --fields=3)
        git -C "${{env.WORK_PATH}}/haiku" tag "$HREV"
    - name: git buildtools
      run:  git -C "${{env.WORK_PATH}}" clone --depth 1 https://review.haiku-os.org/buildtools
    - name: git haikuports
      run: git -C "${{env.WORK_PATH}}" clone --depth 1 https://github.com/haikuports/haikuports
    - name: git haikuporter
      run: git -C "${{env.WORK_PATH}}" clone --depth 1 https://github.com/haikuports/haikuporter
    - name: jam it
      run: cd  "${{env.WORK_PATH}}/buildtools/jam" && make && cp -f bin.linuxx86/jam "${{env.WORK_PATH}}/bin/jam"
    - name: check the jam
      run: jam -v
    - name: setup
      run: mkdir "${{env.WORK_PATH}}/bootstrap"
    # This helps avoiding rebuilds if nothing changed, but it will still rebuild even if something simple
    # and unrelated was changed and commited to Haiku repo, e.g., some text or color.
    # It would be better to know which files/directories impact bootstrap and check only them.
    - name: prepare cache key
      run: |
        git -C "${{env.WORK_PATH}}/haiku" rev-parse HEAD > bootstrap_cache_key
        git -C "${{env.WORK_PATH}}/buildtools" rev-parse HEAD >> bootstrap_cache_key
        git -C "${{env.WORK_PATH}}/haikuporter" rev-parse HEAD >> bootstrap_cache_key
        cat bootstrap_cache_key
    - name: load bootstrap from cache
      uses: actions/cache/restore@v3
      id: cache-bootstrap
      with:
        path: "${{env.WORK_PATH}}/bootstrap"
        key: ${{ runner.os }}-${{ hashFiles('bootstrap_cache_key') }}
    # Run build only if cache is not up to date
    - name: configure
      id: configure
      if: steps.cache-bootstrap.outputs.cache-hit != 'true'
      run: cd "${{env.WORK_PATH}}/bootstrap" && "${{env.WORK_PATH}}/haiku/configure" --build-cross-tools riscv64 --cross-tools-source "${{env.WORK_PATH}}/buildtools" --bootstrap "${{env.WORK_PATH}}/haikuporter/haikuporter" "${{env.WORK_PATH}}/haikuports.cross" "${{env.WORK_PATH}}/haikuports" -j$(nproc)
    # Update cache only if we did actually build anything new successfully
    - name: save bootstrap to cache
      uses: actions/cache/save@v3
      if: steps.configure.outcome == 'success'
      with:
        path: "${{env.WORK_PATH}}/bootstrap"
        key: ${{ steps.cache-bootstrap.outputs.cache-primary-key }}
    # Upload artifacts only if we did actually run the configure step
    # This makes sure that we will upload failed builds too, so they can be checked by devs
    - name: upload bootstrap artifact
      uses: actions/upload-artifact@v3
      if: steps.cache-bootstrap.outputs.cache-hit != 'true'
      with:
        name: bootstrap
        path: "${{env.WORK_PATH}}/bootstrap"
    # Build image
    - name: build
      env:
        HAIKU_PORTER_EXTRA_OPTIONS: "--debug"
      run: cd "${{env.WORK_PATH}}/bootstrap" && jam -q @bootstrap-raw
